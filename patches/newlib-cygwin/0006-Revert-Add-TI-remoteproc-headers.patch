From d5092566ebf05432c37e23e8af0a3e895ae9e6fe Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dimitar@dinux.eu>
Date: Mon, 4 Jun 2018 08:06:15 +0300
Subject: [PATCH 6/8] Revert "Add TI remoteproc headers"

This reverts commit a94b0162d98a447df50dbbae7f6c03a84eaeea75.
---
 libgloss/pru/Makefile.in               |   4 -
 libgloss/pru/include/pru_rpmsg.h       | 223 ---------------------
 libgloss/pru/include/pru_types.h       |  83 --------
 libgloss/pru/include/pru_virtio_ids.h  |  42 ----
 libgloss/pru/include/pru_virtio_ring.h | 159 ---------------
 libgloss/pru/include/pru_virtqueue.h   | 218 ---------------------
 libgloss/pru/include/rsc_types.h       | 347 ---------------------------------
 7 files changed, 1076 deletions(-)
 delete mode 100644 libgloss/pru/include/pru_rpmsg.h
 delete mode 100644 libgloss/pru/include/pru_types.h
 delete mode 100644 libgloss/pru/include/pru_virtio_ids.h
 delete mode 100644 libgloss/pru/include/pru_virtio_ring.h
 delete mode 100644 libgloss/pru/include/pru_virtqueue.h
 delete mode 100644 libgloss/pru/include/rsc_types.h

diff --git a/libgloss/pru/Makefile.in b/libgloss/pru/Makefile.in
index 0920da85c..4baa5c387 100644
--- a/libgloss/pru/Makefile.in
+++ b/libgloss/pru/Makefile.in
@@ -130,10 +130,6 @@ install: $(OUTPUTS) $(srcdir)/ldscripts/gen-ld-scripts.sh
 	  b=`basename $$i`; \
 	  $(INSTALL_DATA) $$i $(DESTDIR)$(tooldir)/include/pru/$$b ;\
 	done
-	for i in ${srcdir}/include/*.h; do \
-	  b=`basename $$i`; \
-	  $(INSTALL_DATA) $$i $(DESTDIR)$(tooldir)/include/$$b ;\
-	done
 	${mkinstalldirs} ${DESTDIR}${tooldir}/lib${MULTISUBDIR}/device-specs; \
 	for s in ${srcdir}/device-specs/*; do \
 	  b=`basename $$s`; \
diff --git a/libgloss/pru/include/pru_rpmsg.h b/libgloss/pru/include/pru_rpmsg.h
deleted file mode 100644
index d5ed79c3e..000000000
--- a/libgloss/pru/include/pru_rpmsg.h
+++ /dev/null
@@ -1,223 +0,0 @@
-/*
- * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/ 
- *  
- *  
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions 
- * are met:
- * 
- * 	* Redistributions of source code must retain the above copyright 
- * 	  notice, this list of conditions and the following disclaimer.
- * 
- * 	* Redistributions in binary form must reproduce the above copyright
- * 	  notice, this list of conditions and the following disclaimer in the 
- * 	  documentation and/or other materials provided with the   
- * 	  distribution.
- * 
- * 	* Neither the name of Texas Instruments Incorporated nor the names of
- * 	  its contributors may be used to endorse or promote products derived
- * 	  from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/**
- *  File	:	pru_rpmsg.h
- *
- *  Summary	:	An RPMsg interface for the PRU to use while communicating with
- *  			the ARM host.
- *
- *  Notes	:
- *  - This file creates a structure (pru_rpmsg_transport) that contains
- *    pointers to two pru_virtqueue structures. This structure is used as the
- *    underlying transport layer of all RPMsg communication. Only one
- *    pru_rpmsg_transport structure is needed because multiple logical channels
- *    can use the same underlying transport.
- *  - This pru_rpmsg interface is meant to sit on top of the pru_virtqueue
- *    interface and abstract the communication even further away from the
- *    underlying data structures. The goal is to make the communication as
- *    simple as possible at the user application level.
- *  - The logic for the PRU side is summarized below:
- *
- *    PRU Slave:
- *    - To receive buffer from the ARM host:
- *          pru_rpmsg_receive(*transport, *src, *dst, *data, *len);
- *    - To send buffer to the host:
- *          pru_rpmsg_send(*transport, src, dst, *data, len);
- */
-
-#ifndef _PRU_RPMSG_H_
-#define _PRU_RPMSG_H_
-
-#include <pru_virtqueue.h>
-
-/* Return value indicating no kick was sent */
-#define PRU_RPMSG_NO_KICK				1
-/* Return value indicating success */
-#define PRU_RPMSG_SUCCESS				0
-/* Return value indicating there were no available buffers */
-#define PRU_RPMSG_NO_BUF_AVAILABLE		-1
-/* Return value indicating that the buffer from the virtqueue was too small */
-#define PRU_RPMSG_BUF_TOO_SMALL			-2
-/* Return value indicating that an invalid head index was given */
-#define PRU_RPMSG_INVALID_HEAD			-3
-
-/* The maximum size of the channel name and description */
-#define RPMSG_NAME_SIZE 32
-/* The maximum size of the buffer (including the header) */
-#define RPMSG_BUF_SIZE	512
-
-enum pru_rpmsg_ns_flags {
-    RPMSG_NS_CREATE = 0,
-    RPMSG_NS_DESTROY = 1
-};
-
-/**
- * Summary		: 	pru_rpmsg_transport is a structure that groups together the
- * 					two pru_virtqueues that are needed for two-way communication
- * 					with the ARM. This structure provides a logical wrapper for
- * 					the transport layer of the application. NOTE: Multiple
- * 					(logical) channels can be implemented on top of the same
- * 					transport layer.
- *
- * Variables	:	virtqueue0: contains the pru_virtqueue that is used for the
- * 								PRU->ARM communication
- * 					virtqueue1: contains the pru_virtqueue that is used for
- * 								the ARM->PRU communication
- */
-struct pru_rpmsg_transport {
-	struct pru_virtqueue 	virtqueue0;
-	struct pru_virtqueue 	virtqueue1;
-};
-
-/**
-* Summary		:	pru_rpmsg_receive receives a message, if available, from
-* 					the ARM host.
-*
-* Parameters	:	transport: a pointer to the transport layer from which the
-* 							   message should be received
-* 					src: a pointer that is populated with the source address
-* 						 where the message originated
-* 					dst: a pointer that is populated with the destination
-* 						 address where the message was sent (can help determine
-* 						 for which channel the message is intended on the PRU)
-* 					data: a pointer that is populated with a local data buffer
-* 						  containing the message payload
-* 					len: a pointer that is populated with the length of the
-* 						 message payload
-*
-* Description	:	pru_rpmsg_receive uses the pru_virtqueue interface to get
-* 					an available buffer, copy the buffer into local memory,
-* 					add the buffer as a used buffer to the vring, and then kick
-* 					the remote processor if necessary. The src, dst, data, and
-* 					len pointers are populated with the information about the
-* 					message and local buffer data if the reception is
-* 					successful.
-*
-* Return Value	:	Returns PRU_RPMSG_NO_BUF_AVAILABLE if there is currently no
-* 					buffer available for receive. Returns PRU_RPMSG_INVALID_HEAD
-* 					if the head index returned for the available buffer is
-* 					invalid. Returns PRU_RPMSG_SUCCESS if the message is
-* 					successfully received.
-*/
-int16_t pru_rpmsg_receive (
-	struct pru_rpmsg_transport 	*transport,
-	uint16_t 					*src,
-	uint16_t 					*dst,
-	void 						*data,
-	uint16_t 					*len
-);
-
-/**
-* Summary		:	pru_rpmsg_send sends a message to the ARM host using the
-* 					virtqueues in the pru_rpmsg_transport structure. The
-* 					source and destination address of the message are passed
-* 					in as parameters to the function. The data to be sent and
-* 					its length are passed in the data and len parameters.
-*
-* Parameters	:	transport: a pointer to the transport layer from which the
-* 							   message should be sent
-* 					src: the source address where this message will originate
-* 					dst: the destination address where the message will be sent
-* 					data: a pointer to a local data buffer containing the
-* 						  message payload
-* 					len: the length of the message payload
-*
-* Description	:	pru_rpmsg_send sends a message to the src parameter and
-* 					from the dst parameter. The transport structure defines the
-* 					underlying transport mechanism that will be used. The
-* 					data parameter is a pointer to a local buffer that should
-* 					be sent to the destination address and the len parameter is
-* 					the length of that buffer.
-*
-* Return Value	:	Returns PRU_RPMSG_NO_BUF_AVAILABLE if there is currently no
-* 					buffer available for send. Returns PRU_RPMSG_BUF_TOO_SMALL
-* 					if the buffer from the vring is too small to hold the
-* 					message payload being sent. Returns PRU_RPMSG_INVALID_HEAD
-* 					if the head index returned for the send buffer is invalid.
-* 					Returns PRU_RPMSG_SUCCESS if the message is successfully
-* 					sent.
-*/
-int16_t pru_rpmsg_send (
-	struct pru_rpmsg_transport 	*transport,
-	uint32_t 					src,
-	uint32_t 					dst,
-	void 						*data,
-	uint16_t 					len
-);
-
-/**
-* Summary		:	pru_rpmsg_channel uses an RPMsg Name Service Announcment
-* 					to either create or destroy an RPMsg channel depending on
-* 					the pru_rpmsg_ns_flags parameter that is specified.
-*
-* Parameters	:	flags: an enum that is used to create (RPMSG_NS_CREATE) or
-* 						   destroy (RPMSG_NS_DESTROY) an RPMsg channel
-* 					transport: a pointer to the transport layer on which this
-* 							   Name Service Announcement will be sent
-* 					name: the name of the channel being created or destroyed
-* 						  ******* The name of the channel is very important as
-* 						  ******* it is the method that Linux on the ARM uses
-* 						  ******* to connect a PRU firmware with a corresponding
-* 						  ******* Linux driver
-* 					desc: the description of the RPMsg channel being created
-* 						  or destroyed
-* 					port: the local source address of the RPMsg channel. This
-* 						  is the address where PRU messages destined for the
-* 						  ARM host will originate
-*
-* Description	:	pru_rpmsg_channel sends a message letting the ARM
-* 					host know that a channel is to be created or destroyed. If
-* 					a channel is to be created then this message will notify
-* 					the name server on the ARM host to create a new channel. If
-* 					a channel is to be destroyed this will tear down this
-* 					logical channel of communication between the PRU and the
-* 					ARM host.
-*
-* Return Value	:	Returns PRU_RPMSG_NO_BUF_AVAILABLE if there is currently no
-* 					buffer available for send. Returns PRU_RPMSG_BUF_TOO_SMALL
-* 					if the buffer from the vring is too small to hold the
-* 					message payload being sent. Returns PRU_RPMSG_INVALID_HEAD
-* 					if the head index returned for the send buffer is invalid.
-* 					Returns PRU_RPMSG_SUCCESS if the message is successfully
-* 					sent.
-*/
-int16_t pru_rpmsg_channel (
-	enum pru_rpmsg_ns_flags 	flags ,
-	struct pru_rpmsg_transport 	*transport,
-	char 						*name,
-	char 						*desc,
-	int32_t 					port
-);
-
-#endif /* _PRU_RPMSG_H_ */
diff --git a/libgloss/pru/include/pru_types.h b/libgloss/pru/include/pru_types.h
deleted file mode 100644
index 5fa62a4f4..000000000
--- a/libgloss/pru/include/pru_types.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/ 
- *  
- *  
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions 
- * are met:
- * 
- * 	* Redistributions of source code must retain the above copyright 
- * 	  notice, this list of conditions and the following disclaimer.
- * 
- * 	* Redistributions in binary form must reproduce the above copyright
- * 	  notice, this list of conditions and the following disclaimer in the 
- * 	  documentation and/or other materials provided with the   
- * 	  distribution.
- * 
- * 	* Neither the name of Texas Instruments Incorporated nor the names of
- * 	  its contributors may be used to endorse or promote products derived
- * 	  from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _PRU_TYPES_H_
-#define _PRU_TYPES_H_
-
-/* Custom Resource info: Must match drivers/remoteproc/pru_rproc.h */
-#define TYPE_PRU_INTS		1
-
-/**
- * struct ch_map - sysevts-to-channel mapping
- *
- * @evt: the number of the sysevt
- * @ch: channel number assigned to a given @sysevt
- *
- * PRU system events are mapped to channels, and these channels are mapped to
- * hosts. Events can be mapped to channels in a one-to-one or many-to-one ratio
- * (multiple events per channel), and channels can be mapped to hosts in a
- * one-to-one or many-to-one ratio (multiple events per channel).
- *
- * @evt is the number of the sysevt, and @ch is the number of the channel to be
- * mapped.
- */
-
-struct ch_map {
-	uint8_t evt;
-	uint8_t ch;
-};
-
-/**
- * struct fw_rsc_custom_ints - custom resource to define PRU interrupts
- * @version: revision number of the custom ints type
- * @channel_host: assignment of PRU channels to hosts
- * @num_evts: device address of INTC
- * @event_channel: mapping of sysevts to channels
- *
- * PRU system events are mapped to channels, and these channels are mapped to
- * hosts. Events can be mapped to channels in a one-to-one or many-to-one ratio
- * (multiple events per channel), and channels can be mapped to hosts in a
- * one-to-one or many-to-one ratio (multiple events per channel).
- *
- * @da is the device address of the interrupt controller, @channel_map is
- * used to specify to which channel, if any, an event is mapped, and @host_map
- * specifies to which host, if any, a channel is mapped.
- */
-struct fw_rsc_custom_ints {
-	uint16_t version;
-	uint8_t channel_host[10];
-	uint32_t num_evts;
-	struct ch_map *event_channel;
-};
-
-#endif /* _PRU_TYPES_H_ */
diff --git a/libgloss/pru/include/pru_virtio_ids.h b/libgloss/pru/include/pru_virtio_ids.h
deleted file mode 100644
index a7630d040..000000000
--- a/libgloss/pru/include/pru_virtio_ids.h
+++ /dev/null
@@ -1,42 +0,0 @@
-#ifndef _LINUX_VIRTIO_IDS_H
-#define _LINUX_VIRTIO_IDS_H
-/*
- * Virtio IDs
- *
- * This header is BSD licensed so anyone can use the definitions to implement
- * compatible drivers/servers.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of IBM nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE. */
-
-#define VIRTIO_ID_NET		1 /* virtio net */
-#define VIRTIO_ID_BLOCK		2 /* virtio block */
-#define VIRTIO_ID_CONSOLE	3 /* virtio console */
-#define VIRTIO_ID_RNG		4 /* virtio rng */
-#define VIRTIO_ID_BALLOON	5 /* virtio balloon */
-#define VIRTIO_ID_RPMSG		7 /* virtio remote processor messaging */
-#define VIRTIO_ID_SCSI		8 /* virtio scsi */
-#define VIRTIO_ID_9P		9 /* 9p virtio console */
-#define VIRTIO_ID_RPROC_SERIAL 11 /* virtio remoteproc serial link */
-
-#endif /* _LINUX_VIRTIO_IDS_H */
diff --git a/libgloss/pru/include/pru_virtio_ring.h b/libgloss/pru/include/pru_virtio_ring.h
deleted file mode 100644
index 6cbb32f79..000000000
--- a/libgloss/pru/include/pru_virtio_ring.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* An interface for efficient virtio implementation, currently for use by KVM
- * and lguest, but hopefully others soon.  Do NOT change this since it will
- * break existing servers and clients.
- *
- * This header is BSD licensed so anyone can use the definitions to implement
- * compatible drivers/servers.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of IBM nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * Copyright Rusty Russell IBM Corporation 2007. */
-#include <stdint.h>
-
-/* This marks a buffer as continuing via the next field. */
-#define VRING_DESC_F_NEXT	1
-/* This marks a buffer as write-only (otherwise read-only). */
-#define VRING_DESC_F_WRITE	2
-/* This means the buffer contains a list of buffer descriptors. */
-#define VRING_DESC_F_INDIRECT	4
-
-/* The Host uses this in used->flags to advise the Guest: don't kick me when
- * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
- * will still kick if it's out of buffers. */
-#define VRING_USED_F_NO_NOTIFY	1
-/* The Guest uses this in avail->flags to advise the Host: don't interrupt me
- * when you consume a buffer.  It's unreliable, so it's simply an
- * optimization.  */
-#define VRING_AVAIL_F_NO_INTERRUPT	1
-
-/* We support indirect buffer descriptors */
-#define VIRTIO_RING_F_INDIRECT_DESC	28
-
-/* The Guest publishes the used index for which it expects an interrupt
- * at the end of the avail ring. Host should ignore the avail->flags field. */
-/* The Host publishes the avail index for which it expects a kick
- * at the end of the used ring. Guest should ignore the used->flags field. */
-#define VIRTIO_RING_F_EVENT_IDX		29
-
-/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
-struct vring_desc {
-	/* Address (guest-physical). */
-	uint64_t addr;
-	/* Length. */
-	uint32_t len;
-	/* The flags as indicated above. */
-	uint16_t flags;
-	/* We chain unused descriptors via this, too */
-	uint16_t next;
-};
-
-struct vring_avail {
-	uint16_t flags;
-	uint16_t idx;
-	uint16_t ring[];
-};
-
-/* u32 is used here for ids for padding reasons. */
-struct vring_used_elem {
-	/* Index of start of used descriptor chain. */
-	uint32_t id;
-	/* Total length of the descriptor chain which was used (written to) */
-	uint32_t len;
-};
-
-struct vring_used {
-	uint16_t flags;
-	uint16_t idx;
-	struct vring_used_elem ring[];
-};
-
-struct vring {
-	uint32_t num;
-
-	struct vring_desc *desc;
-
-	struct vring_avail *avail;
-
-	struct vring_used *used;
-};
-
-/* The standard layout for the ring is a continuous chunk of memory which looks
- * like this.  We assume num is a power of 2.
- *
- * struct vring
- * {
- *	// The actual descriptors (16 bytes each)
- *	struct vring_desc desc[num];
- *
- *	// A ring of available descriptor heads with free-running index.
- *	__u16 avail_flags;
- *	__u16 avail_idx;
- *	__u16 available[num];
- *	__u16 used_event_idx;
- *
- *	// Padding to the next align boundary.
- *	char pad[];
- *
- *	// A ring of used descriptor heads with free-running index.
- *	__u16 used_flags;
- *	__u16 used_idx;
- *	struct vring_used_elem used[num];
- *	__u16 avail_event_idx;
- * };
- */
-/* We publish the used event index at the end of the available ring, and vice
- * versa. They are at the end for backwards compatibility. */
-#define vring_used_event(vr) ((vr)->avail->ring[(vr)->num])
-#define vring_avail_event(vr) (*(__u16 *)&(vr)->used->ring[(vr)->num])
-
-static inline void vring_init(struct vring *vr, uint32_t num, void *p,
-			      uint64_t align)
-{
-	vr->num = num;
-	vr->desc = p;
-	vr->avail = (void *)((char *)p + num*sizeof(struct vring_desc));
-	vr->used = (void *)(uintptr_t)(((uint64_t)&vr->avail->ring[num]
-		+ sizeof(uint16_t) + align-1) & ~(align - 1));
-}
-
-static inline unsigned vring_size(uint16_t num, uint64_t align)
-{
-	return ((sizeof(struct vring_desc) * num + sizeof(uint16_t) * (3 + num)
-		 + align - 1) & ~(align - 1))
-		+ sizeof(uint16_t) * 3 + sizeof(struct vring_used_elem) * num;
-}
-
-/* The following is used with USED_EVENT_IDX and AVAIL_EVENT_IDX */
-/* Assuming a given event_idx value from the other size, if
- * we have just incremented index from old to new_idx,
- * should we trigger an event? */
-static inline int vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
-{
-	/* Note: Xen has similar logic for notification hold-off
-	 * in include/xen/interface/io/ring.h with req_event and req_prod
-	 * corresponding to event_idx + 1 and new_idx respectively.
-	 * Note also that req_event and req_prod in Xen start at 1,
-	 * event indexes in virtio start at 0. */
-	return (uint16_t)(new_idx - event_idx - 1) < (uint16_t)(new_idx - old);
-}
diff --git a/libgloss/pru/include/pru_virtqueue.h b/libgloss/pru/include/pru_virtqueue.h
deleted file mode 100644
index b687bb7f8..000000000
--- a/libgloss/pru/include/pru_virtqueue.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2015 Texas Instruments Incorporated - http://www.ti.com/ 
- *  
- *  
- * Redistribution and use in source and binary forms, with or without 
- * modification, are permitted provided that the following conditions 
- * are met:
- * 
- * 	* Redistributions of source code must retain the above copyright 
- * 	  notice, this list of conditions and the following disclaimer.
- * 
- * 	* Redistributions in binary form must reproduce the above copyright
- * 	  notice, this list of conditions and the following disclaimer in the 
- * 	  documentation and/or other materials provided with the   
- * 	  distribution.
- * 
- * 	* Neither the name of Texas Instruments Incorporated nor the names of
- * 	  its contributors may be used to endorse or promote products derived
- * 	  from this software without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
- /**
- *  File	:	pru_virtqueue.h
- *
- *  Summary	:	A virtual queue interface to simplify vring usage.
- *
- *  Notes	:
- *  - This file implements the vring functions needed by the PRU core
- *  - The PRU core is considered the slave and the ARM core is considered the
- *	  host
- *  - The ARM host always adds *available* buffers to send/receive, while the
- *    PRU slave always adds *used* buffers to send/receive.
- *  - The logic for the PRU side is summarized below:
- *
- *    PRU Slave:
- *    - To receive buffer from the ARM host:
- *          virtqueue_getAvailBuf(vq_slave);
- *              >> empty data from buf <<
- *          virtqueue_addUsedBuf(vq_slave);
- *          virtqueue_kick(vq_slave);
- *    - To send buffer to the host:
- *          virtqueue_getAvailBuf(vq_host);
- *              >> copy data into buf <<
- *          virtqueue_addUsedBuf(vq_host);
- *          virtqueue_kick(vq_host);
- */
-
-#ifndef _PRU_VIRTQUEUE_H_
-#define _PRU_VIRTQUEUE_H_
-
-#include <stdint.h>
-#include <rsc_types.h>
-#include <pru_virtio_ring.h>
-#include <sys_mailbox.h>
-
-/* Return value indicating no kick was sent */
-#define PRU_VIRTQUEUE_NO_KICK				1
-/* Return value indicating success */
-#define PRU_VIRTQUEUE_SUCCESS				0
-/* Return value indicating there were no available buffers */
-#define PRU_VIRTQUEUE_NO_BUF_AVAILABLE		-1
-/* Return value indicating that an invalid head index was given */
-#define PRU_VIRTQUEUE_INVALID_HEAD			-2
-
-/**
- * Summary		: 	pru_virtqueue is a structure that encapsulates everything
- * 					needed for a 'virtual queue'. This structure wraps a vring
- * 					with extra information that is needed by the application
- * 					in order to use the vring.
- *
- * Variables	:	id: The notification ID of the vring. When a kick is
- * 						generated the id of the vring being kicked is placed
- * 						into a mailbox. This is how the ARM host and the PRU
- * 						determine whether a kick is for a receive operation or
- * 						a sentbuffer being consumed.
- * 					toArmMbx: The mailbox number that is used for communication
- * 							  in the PRU->ARM direction.
- * 					fromArmMbx: The mailbox number that is used for the
- * 								communication in the ARM->PRU direction.
- * 					last_avail_idx: A local running counter that is used by the
- * 									PRU to determine whether or not a new
- * 									available buffer has been added to the
- * 									vring.
- * 					vring: The underlying virtio structure that is being used
- * 						   to pass buffers back and forth between the ARM and
- * 						   PRU. See pru_virtio_ring.h.
- */
-struct pru_virtqueue {
-	uint32_t		id;
-	uint32_t		to_arm_mbx;
-	uint32_t		from_arm_mbx;
-	uint32_t 		last_avail_idx;
-	struct vring 	vring;
-};
-
-/**
-* Summary		:	pru_virtqueue_init initializes the pru_virtqueue structure
-* 					with values from the resource table.
-*
-* Parameters	:	vq: a pointer to a pru_virtqueue structure that will be
-* 						initialized
-* 					vring: a pointer to a vring that is populated and returned
-* 						   by the ARM host through the resource table (the id,
-* 						   number of descriptors, address of the vring, and
-* 						   alignment information are contained in this vring
-* 						   pointer's structure
-* 					to_arm_mbx: the mailbox number to write to in order to
-* 								'kick' the ARM host when sending data
-* 					from_arm_mbx: the mailbox number to read from to check
-* 								  for data arriving from the ARM host
-*
-* Description	:	This function initializes the pru_virtqueue (vq) with input
-* 					values from the vring in the resource table. This function
-* 					should be called once for each virtqueue/vring. After
-* 					initialization the pru_virtqueue pointer, vq, should be
-* 					passed to the other functions in this header file.
-*
-* Return Value	:	No return value.
-*/
-void pru_virtqueue_init (
-	struct pru_virtqueue 		*vq,
-	struct fw_rsc_vdev_vring 	*vring,
-	uint32_t 					to_arm_mbx,
-	uint32_t 					from_arm_mbx
-);
-
-/**
-* Summary		:	pru_virtqueue_get_avail_buf - gets the next available
-* 					buffer from the pru_virtqueue specified in vq.
-*
-* Parameters	:	vq: pointer to the pru_virtqueue from which the available
-* 						buffer should be retrieved
-* 					buf: pointer to be filled with the address of the available
-* 						 buffer
-* 					len: pointer to be filled with the length of the available
-* 						 buffer
-*
-* Description	:	This function compares our last_avail_idx running counter
-* 					against the vring.avail->idx value to see if there is a
-* 					buffer available that we have not used. If our last
-* 					available index running counter matches the vring.avail->idx
-* 					value then there have been no new available buffers added
-* 					by the host. If the two indices do not match then the host
-* 					has added new buffers and and we can set @buf to point to
-* 					the available buffer and @len to match the available buffers
-* 					length. If an available buffer is found we increment out
-* 					last_avail_idx to show that we used another buffer.
-*
-* Return Value	:	PRU_VIRTQUEUE_NO_BUF_AVAILABLE if no buffer available.
-* 					Returns the vring.desc index of the available buffer
-* 					otherwise.
-*/
-int16_t pru_virtqueue_get_avail_buf (
-	struct pru_virtqueue 	*vq,
-	void 					**buf,
-	uint32_t 				*len
-);
-
-/**
-* Summary		:	pru_virtqueue_add_used_buf adds a used buffer to the
-* 					pru_virtqueue specified in vq.
-*
-* Parameters	:	vq: pointer to the pru_virtqueue where the used buffer
-* 						should be added
-* 					head: vring.desc[] index of the used buffer
-* 					len: length of the used buffer being added
-*
-* Description	:	This function makes sure that the head vring.desc index
-* 					(head) is a valid index. If the index is valid, then the
-* 					buffer is added to the used list in the vring contained by
-* 					the pru_virtqueue (vq).
-*
-* Return Value	:	PRU_VIRTQUEUE_INVALID_HEAD if head is an invalid index for
-* 					the vring.desc array. Returns PRU_VIRTQUEUE_SUCCESS
-* 					otherwise.
-*/
-int16_t pru_virtqueue_add_used_buf (
-	struct pru_virtqueue 	*vq,
-	int16_t 				head,
-	uint32_t 				len
-);
-
-/**
-* Summary		:	pru_virtqueue_kick sends a notification to the remote
-* 					processor that the PRU has added a buffer to the
-* 					pru_virtqueue.
-*
-* Parameters	:	vq: pointer to the pru_virtqueue that is to be kicked
-*
-* Description	:	This function is used by the PRU to notify the ARM host in
-* 					two situations:
-* 						1. 	That the PRU has consumed a buffer that the ARM
-* 							host sent through the slave pru_virtqueue
-*						2. 	That the PRU has sent a buffer to the ARM through
-*							the host pru_virtqueue
-*					If the pru_virtqueue's VRING_AVAIL_F_NO_INTERRUPT flag is
-*					set then the pru does not kick the pru_virtqueue.
-*
-* Return Value	:	PRU_VIRTQUEUE_NO_KICK if the VRING_AVAIL_F_NO_INTERRUPT
-* 					flag is set or PRU_VIRTQUEUE_SUCCESS otherwise.
-*/
-int16_t pru_virtqueue_kick (
-	struct pru_virtqueue 	*vq
-);
-
-#endif /* _PRU_VIRTQUEUE_H_ */
diff --git a/libgloss/pru/include/rsc_types.h b/libgloss/pru/include/rsc_types.h
deleted file mode 100644
index 755ab601b..000000000
--- a/libgloss/pru/include/rsc_types.h
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * Copyright(c) 2011 Texas Instruments, Inc.
- * Copyright(c) 2011 Google, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * * Redistributions of source code must retain the above copyright
- *   notice, this list of conditions and the following disclaimer.
- * * Redistributions in binary form must reproduce the above copyright
- *   notice, this list of conditions and the following disclaimer in
- *   the documentation and/or other materials provided with the
- *   distribution.
- * * Neither the name Texas Instruments nor the names of its
- *   contributors may be used to endorse or promote products derived
- *   from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef _RSC_TYPES_H_
-#define _RSC_TYPES_H_
-
-#include <stdint.h>
-#include <pru_types.h>
-
-/* Size constants must match those used on host */
-#define SZ_4K			(0x00001000)
-#define SZ_8K			(0x00002000)
-
-/* Resource info: Must match include/linux/remoteproc.h: */
-#define TYPE_CARVEOUT		0
-#define TYPE_DEVMEM		1
-#define TYPE_TRACE		2
-#define TYPE_VDEV		3
-#define TYPE_INTMEM		4
-#define TYPE_CUSTOM		5
-
-union fw_custom {
-	/* add custom resources here */
-	struct fw_rsc_custom_ints pru_ints;
-	/* maintain reserved as the last element */
-	uint32_t reserved;
-};
-
-/* Common Resource Structure Types */
-
-/**
- * struct resource_table - firmware resource table header
- * @ver: version number
- * @num: number of resource entries
- * @reserved: reserved (must be zero)
- *
- * A resource table is essentially a list of system resources required
- * by the remote processor. It may also include configuration entries.
- * If needed, the remote processor firmware should contain this table
- * as a dedicated ".resource_table" ELF section.
- *
- * Some resources entries are mere announcements, where the host is informed
- * of specific remoteproc configuration. Other entries require the host to
- * do something (e.g. allocate a system resource). Sometimes a negotiation
- * is expected, where the firmware requests a resource, and once allocated,
- * the host should provide back its details (e.g. address of an allocated
- * memory region).
- *
- * The header of the resource table, as expressed by this structure,
- * contains a version number (should we need to change this format in the
- * future), the number of available resource entries, and their offsets
- * in the table.
- *
- * Immediately following this header are the resource entries themselves,
- * each of which begins with a resource entry header (as described below).
- */
-struct resource_table {
-	uint32_t ver;
-	uint32_t num;
-	uint32_t reserved[2];
-};
-
-/**
- * struct fw_rsc_carveout - physically contiguous memory request
- * @type: type of resource
- * @da: device address
- * @pa: physical address
- * @len: length (in bytes)
- * @flags: iommu protection flags
- * @reserved: reserved (must be zero)
- * @name: human-readable name of the requested memory region
- *
- * This resource entry requests the host to allocate a physically contiguous
- * memory region.
- *
- * These request entries should precede other firmware resource entries,
- * as other entries might request placing other data objects inside
- * these memory regions (e.g. data/code segments, trace resource entries, ...).
- *
- * Allocating memory this way helps utilizing the reserved physical memory
- * (e.g. CMA) more efficiently, and also minimizes the number of TLB entries
- * needed to map it (in case @rproc is using an IOMMU). Reducing the TLB
- * pressure is important; it may have a substantial impact on performance.
- *
- * If the firmware is compiled with static addresses, then @da should specify
- * the expected device address of this memory region. If @da is set to
- * FW_RSC_ADDR_ANY, then the host will dynamically allocate it, and then
- * overwrite @da with the dynamically allocated address.
- *
- * We will always use @da to negotiate the device addresses, even if it
- * isn't using an iommu. In that case, though, it will obviously contain
- * physical addresses.
- *
- * Some remote processors needs to know the allocated physical address
- * even if they do use an iommu. This is needed, e.g., if they control
- * hardware accelerators which access the physical memory directly (this
- * is the case with OMAP4 for instance). In that case, the host will
- * overwrite @pa with the dynamically allocated physical address.
- * Generally we don't want to expose physical addresses if we don't have to
- * (remote processors are generally _not_ trusted), so we might want to
- * change this to happen _only_ when explicitly required by the hardware.
- *
- * @flags is used to provide IOMMU protection flags, and @name should
- * (optionally) contain a human readable name of this carveout region
- * (mainly for debugging purposes).
- */
-struct fw_rsc_carveout {
-	uint32_t type;
-	uint32_t da;
-	uint32_t pa;
-	uint32_t len;
-	uint32_t flags;
-	uint32_t reserved;
-	uint8_t name[32];
-};
-
-/**
- * struct fw_rsc_devmem - iommu mapping request
- * @type: type of resource
- * @da: device address
- * @pa: physical address
- * @len: length (in bytes)
- * @flags: iommu protection flags
- * @reserved: reserved (must be zero)
- * @name: human-readable name of the requested region to be mapped
- *
- * This resource entry requests the host to iommu map a physically contiguous
- * memory region. This is needed in case the remote processor requires
- * access to certain memory-based peripherals; _never_ use it to access
- * regular memory.
- *
- * This is obviously only needed if the remote processor is accessing memory
- * via an iommu.
- *
- * @da should specify the required device address, @pa should specify
- * the physical address we want to map, @len should specify the size of
- * the mapping and @flags is the IOMMU protection flags. As always, @name may
- * (optionally) contain a human readable name of this mapping (mainly for
- * debugging purposes).
- *
- * Note: at this point we just "trust" those devmem entries to contain valid
- * physical addresses, but this isn't safe and will be changed: eventually we
- * want remoteproc implementations to provide us ranges of physical addresses
- * the firmware is allowed to request, and not allow firmwares to request
- * access to physical addresses that are outside those ranges.
- */
-struct fw_rsc_devmem {
-	uint32_t type;
-	uint32_t da;
-	uint32_t pa;
-	uint32_t len;
-	uint32_t flags;
-	uint32_t reserved;
-	uint8_t name[32];
-};
-
-/**
- * struct fw_rsc_trace - trace buffer declaration
- * @type: type of resource
- * @da: device address
- * @len: length (in bytes)
- * @reserved: reserved (must be zero)
- * @name: human-readable name of the trace buffer
- *
- * This resource entry provides the host information about a trace buffer
- * into which the remote processor will write log messages.
- *
- * @da specifies the device address of the buffer, @len specifies
- * its size, and @name may contain a human readable name of the trace buffer.
- *
- * After booting the remote processor, the trace buffers are exposed to the
- * user via debugfs entries (called trace0, trace1, etc..).
- */
-struct fw_rsc_trace {
-	uint32_t type;
-	uint32_t da;
-	uint32_t len;
-	uint32_t reserved;
-	uint8_t name[32];
-};
-
-/**
- * struct fw_rsc_vdev_vring - vring descriptor entry
- * @da: device address
- * @align: the alignment between the consumer and producer parts of the vring
- * @num: num of buffers supported by this vring (must be power of two)
- * @notifyid is a unique rproc-wide notify index for this vring. This notify
- * index is used when kicking a remote processor, to let it know that this
- * vring is triggered.
- * @reserved: reserved (must be zero)
- *
- * This descriptor is not a resource entry by itself; it is part of the
- * vdev resource type (see below).
- *
- * Note that @da should either contain the device address where
- * the remote processor is expecting the vring, or indicate that
- * dynamically allocation of the vring's device address is supported.
- */
-struct fw_rsc_vdev_vring {
-	uint32_t da;
-	uint32_t align;
-	uint32_t num;
-	uint32_t notifyid;
-	uint32_t reserved;
-};
-
-/**
- * struct fw_rsc_vdev - virtio device header
- * @type: type of resource
- * @id: virtio device id (as in virtio_ids.h)
- * @notifyid is a unique rproc-wide notify index for this vdev. This notify
- * index is used when kicking a remote processor, to let it know that the
- * status/features of this vdev have changes.
- * @dfeatures specifies the virtio device features supported by the firmware
- * @gfeatures is a place holder used by the host to write back the
- * negotiated features that are supported by both sides.
- * @config_len is the size of the virtio config space of this vdev. The config
- * space lies in the resource table immediate after this vdev header.
- * @status is a place holder where the host will indicate its virtio progress.
- * @num_of_vrings indicates how many vrings are described in this vdev header
- * @reserved: reserved (must be zero)
- * @vring is an array of @num_of_vrings entries of 'struct fw_rsc_vdev_vring'.
- *
- * This resource is a virtio device header: it provides information about
- * the vdev, and is then used by the host and its peer remote processors
- * to negotiate and share certain virtio properties.
- *
- * By providing this resource entry, the firmware essentially asks remoteproc
- * to statically allocate a vdev upon registration of the rproc (dynamic vdev
- * allocation is not yet supported).
- *
- * Note: unlike virtualization systems, the term 'host' here means
- * the Linux side which is running remoteproc to control the remote
- * processors. We use the name 'gfeatures' to comply with virtio's terms,
- * though there isn't really any virtualized guest OS here: it's the host
- * which is responsible for negotiating the final features.
- * Yeah, it's a bit confusing.
- *
- * Note: immediately following this structure is the virtio config space for
- * this vdev (which is specific to the vdev; for more info, read the virtio
- * spec). the size of the config space is specified by @config_len.
- */
-struct fw_rsc_vdev {
-	uint32_t type;
-	uint32_t id;
-	uint32_t notifyid;
-	uint32_t dfeatures;
-	uint32_t gfeatures;
-	uint32_t config_len;
-	uint8_t status;
-	uint8_t num_of_vrings;
-	uint8_t reserved[2];
-	struct fw_rsc_vdev_vring vring[0];
-};
-
-/**
- * struct fw_rsc_intmem - internal memory publishing request
- * @type: type of resource
- * @da: device address
- * @pa: physical address
- * @len: length (in bytes)
- * @reserved: reserved (must be zero)
- * @name: human-readable name of the region being published
- *
- * This resource entry allows a remote processor to publish an internal
- * memory region to the host. This resource type allows a remote processor
- * to publish the whole or just a portion of certain internal memories,
- * while it owns and manages any unpublished portion (eg: a shared L1
- * memory that can be split configured as RAM and/or cache). This is
- * primarily provided to allow a host to load code/data into internal
- * memories, the memory for which is neither allocated nor required to
- * be mapped into an iommu.
- *
- * @da should specify the required address as accessible by the device
- * without going through an iommu, @pa should specify the physical address
- * for the region as seen on the bus, @len should specify the size of the
- * memory region. As always, @name may (optionally) contain a human readable
- * name of this mapping (mainly for debugging purposes).
- *
- * Note: at this point we just "trust" these intmem entries to contain valid
- * physical bus addresses. these are not currently intended to be managed
- * as host-controlled heaps, as it is much better to do that from the remote
- * processor side.
- */
-
-struct fw_rsc_intmem {
-	uint32_t type;
-	uint32_t da;
-	uint32_t pa;
-	uint32_t len;
-	uint32_t reserved[2];
-	char name[32];
-};
-
-/**
- * struct fw_rsc_custom - used for custom resource types
- * @type: type of resource
- * @sub_type: type of custom resource
- * @rsc_size: size of @rsc (in bytes)
- * @rsc: the custom resource
- *
- * This resource allows for custom resources specific to an architecture or
- * device.
- *
- * @type is the generic CUSTOM type, @sub_type is the specific custom resource,
- * @rsc_size is the length of @rsc (in bytes), and @rsc is the actual
- * parameters. These will be interpreted by the host-side device-specific
- * driver.
- */
-
-struct fw_rsc_custom {
-	uint32_t type;
-	uint32_t sub_type;
-	uint32_t rsc_size;
-	union fw_custom rsc;
-};
-
-#endif /* _RSC_TYPES_H_ */
-- 
2.11.0

