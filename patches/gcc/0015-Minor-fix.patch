From c318e866ec2dbbf2e1143f7cba9164b78f9f8e0c Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dimitar@dinux.eu>
Date: Sun, 7 Oct 2018 21:31:40 +0300
Subject: [PATCH 15/19] Minor fix

Signed-off-by: Dimitar Dimitrov <dimitar@dinux.eu>
---
 gcc/config/pru/predicates.md |  4 ++--
 gcc/config/pru/pru-passes.c  | 16 ++++------------
 gcc/config/pru/pru-pragma.c  | 16 +++++-----------
 gcc/config/pru/pru.c         |  7 +++----
 4 files changed, 14 insertions(+), 29 deletions(-)

diff --git a/gcc/config/pru/predicates.md b/gcc/config/pru/predicates.md
index 6472c8232c0..1b39c63041c 100644
--- a/gcc/config/pru/predicates.md
+++ b/gcc/config/pru/predicates.md
@@ -178,7 +178,7 @@
       if (GET_CODE (elt) != SET
 	  || GET_CODE (SET_DEST (elt)) != REG
 	  || GET_MODE (SET_DEST (elt)) != elt_mode
-	  || REGNO (SET_DEST (elt)) != dest_regno + i
+	  || REGNO (SET_DEST (elt)) != dest_regno + i * GET_MODE_SIZE (elt_mode)
 	  || GET_CODE (SET_SRC (elt)) != MEM
 	  || GET_MODE (SET_SRC (elt)) != elt_mode)
 	return false;
@@ -230,7 +230,7 @@
       if (GET_CODE (elt) != SET
 	  || GET_CODE (SET_SRC (elt)) != REG
 	  || GET_MODE (SET_SRC (elt)) != elt_mode
-	  || REGNO (SET_SRC (elt)) != src_regno + i
+	  || REGNO (SET_SRC (elt)) != src_regno + i * GET_MODE_SIZE (elt_mode)
 	  || GET_CODE (SET_DEST (elt)) != MEM
 	  || GET_MODE (SET_DEST (elt)) != elt_mode)
 	return false;
diff --git a/gcc/config/pru/pru-passes.c b/gcc/config/pru/pru-passes.c
index 34516540559..aa4f73c4ddb 100644
--- a/gcc/config/pru/pru-passes.c
+++ b/gcc/config/pru/pru-passes.c
@@ -36,7 +36,6 @@
 #include "gimple-walk.h"
 #include "gimple-expr.h"
 #include "tree-pass.h"
-#include "gimple-pretty-print.h"
 
 #include "pru-protos.h"
 
@@ -116,10 +115,8 @@ chk_function_decl (const_tree fntype, location_t call_location)
     {
       tree arg_type = TREE_VALUE (p);
       if (chkp_type_has_function_pointer (arg_type))
-	{
-	  error_at (call_location,
-		    "function pointers not supported with %<-mabi=ti%> option");
-	}
+	error_at (call_location,
+		  "function pointers not supported with %<-mabi=ti%> option");
     }
 }
 
@@ -149,9 +146,6 @@ check_op_callback (tree *tp, int *walk_subtrees, void *data)
       && gimple_call_fndecl (call))
     return NULL;
 
-  /* TODO - find a safe method to allow data-pointer-casted function
-     labels. Example: (void *)func.  */
-
   switch (TREE_CODE (type))
     {
     case FUNCTION_TYPE:
@@ -166,10 +160,8 @@ check_op_callback (tree *tp, int *walk_subtrees, void *data)
 	    {
 	      tree arg_type = TREE_VALUE (p);
 	      if (chkp_type_has_function_pointer (arg_type))
-		{
-		  error_at (gimple_location (wi->stmt), "function pointers "
-			    "not supported with %<-mabi=ti%> option");
-		}
+		error_at (gimple_location (wi->stmt), "function pointers "
+			  "not supported with %<-mabi=ti%> option");
 	    }
 	  break;
 	}
diff --git a/gcc/config/pru/pru-pragma.c b/gcc/config/pru/pru-pragma.c
index decc548a468..6df46bcd78f 100644
--- a/gcc/config/pru/pru-pragma.c
+++ b/gcc/config/pru/pru-pragma.c
@@ -56,19 +56,13 @@ pru_pragma_ctable_entry (cpp_reader * reader ATTRIBUTE_UNUSED)
 
 	  type = pragma_lex (&base_addr);
 	  if (type != CPP_EOF)
-	    {
-	      error ("junk at end of %<#pragma CTABLE_ENTRY%>");
-	    }
+	    error ("junk at end of %<#pragma CTABLE_ENTRY%>");
 	  else if (i >= ARRAY_SIZE (pru_ctable))
-	    {
-	      error ("%<CTABLE_ENTRY%> index %" HOST_WIDE_INT_PRINT "d"
-		     " is not valid", i);
-	    }
+	    error ("%<CTABLE_ENTRY%> index %" HOST_WIDE_INT_PRINT "d"
+		   " is not valid", i);
 	  else if (pru_ctable[i].valid && pru_ctable[i].base != base)
-	    {
-	      error ("redefinition of %<CTABLE_ENTRY "
-		     "%" HOST_WIDE_INT_PRINT "d%>", i);
-	    }
+	    error ("redefinition of %<CTABLE_ENTRY "
+		   "%" HOST_WIDE_INT_PRINT "d%>", i);
 	  else
 	    {
 	      if (base & 0xff)
diff --git a/gcc/config/pru/pru.c b/gcc/config/pru/pru.c
index 245c8b98281..19adac9ec19 100644
--- a/gcc/config/pru/pru.c
+++ b/gcc/config/pru/pru.c
@@ -153,7 +153,7 @@ pru_compute_frame_layout (void)
    frame-related registers.
      op0	  - Destination register.
      op1	  - First addendum operand (a register).
-     addendum     - Second addendum operand (a constant).
+     addendum	  - Second addendum operand (a constant).
      kind	  - Note kind.  REG_NOTE_MAX if no note must be added.
      reg_note_rtx - Reg note RTX.  NULL if it should be computed automatically.
  */
@@ -292,9 +292,8 @@ pru_expand_prologue (void)
   if (!UBYTE_INT (total_frame_size))
     {
       /* We need an intermediary point, this will point at the spill block.  */
-      insn = pru_add_to_sp (cfun->machine->save_regs_offset
-			     - total_frame_size,
-			     REG_NOTE_MAX);
+      insn = pru_add_to_sp (cfun->machine->save_regs_offset - total_frame_size,
+			    REG_NOTE_MAX);
       save_regs_base = 0;
       sp_offset = -cfun->machine->save_regs_offset;
     }
-- 
2.11.0

